{"version":3,"sources":["minimux.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_typeof","Symbol","iterator","obj","constructor","reducers","callbacks","middleware","state","mutableState","callbackOnion","coreFunction","action","type","forEach","el","Object","keys","key","dispatch","rerender","arguments","undefined","Array","isArray","idx","hasOwnProperty","sort","b","priority","reduce","nextLayer","layer","currentAction","func","updater","enqueueForceUpdate","register","actions","reducer","push","listen","callback","connect","unlisten","index","indexOf","splice","use","newMiddleware","unshift","apply","getState"],"mappings":"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","file":"minimux.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n/*\n * Minimux v1.0.2\n * Author: Steven Barnett (stevendesu) <steven.abarnett@gmail.com>\n * License: MIT +no-false-attribs (https://spdx.org/licenses/MITNFA.html)\n *\n * I made this library because I liked the ideology of Redux, but not the\n * implementation. This is my attempt to rebuild Redux with absolute minimal\n * functionality and to allow for absolute minimal bootstrapping in order to\n * write effective code.\n *\n * There are four main API endpoints:\n *  - dispatch(action, [data])\n *     This is the only valid way to modify the state\n *  - on(actions, reducer)\n *     When an action is thrown, apply the reducers\n *  - bind(callback)\n *     Callback will be called with the current state whenever state changes\n *  - apply(middleware, [priority])\n *     Applies middleware to the dispatch function (see documentation)\n *\n * Considerations:\n *  - Should it be possible to connect to a subset of the state? If you could\n *    bind reducers to subsets of state then it would be more modular\n */\n\nvar reducers = {};\nvar callbacks = [];\nvar middleware = [];\n\nvar state = {};\nvar mutableState = {};\n\n// The \"onion\" describes the layers of middleware that we must parse through\n// in order to execute our action.\nvar callbackOnion = null;\n\nvar coreFunction = function coreFunction(action) {\n\tif (reducers[action.type]) {\n\t\treducers[action.type].forEach(function (el) {\n\t\t\tstate = el(state, action);\n\t\t\t// This is a temporary (and hideous) hack to maintain backwards compatibility until I'm happy enough with\n\t\t\t// the API to release v2.0.0\n\t\t\t// Previously you could \"import { state } from 'minimux'\" and it was properly updated\n\t\t\t// This was poor practice because it allowed anyone to edit the state without using actions\n\t\t\t// A getState() function has been added to return only the most recent immutable state\n\t\t\tObject.keys(mutableState).forEach(function (key) {\n\t\t\t\tdelete mutableState[key];\n\t\t\t});\n\t\t\tObject.keys(state).forEach(function (key) {\n\t\t\t\tmutableState[key] = state[key];\n\t\t\t});\n\t\t});\n\t}\n\treturn state;\n};\n\nvar dispatch = function dispatch(action) {\n\tvar rerender = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n\tif (\"development\" !== \"production\") {\n\t\tif ((typeof action === \"undefined\" ? \"undefined\" : _typeof(action)) !== \"object\") {\n\t\t\tthrow \"Invalid type (\" + (typeof action === \"undefined\" ? \"undefined\" : _typeof(action)) + \") for argument \\\"action\\\" passed to dispatch. Expected \" + \"object or array of objects.\";\n\t\t}\n\t\tif (Array.isArray(action)) {\n\t\t\taction.forEach(function (el, idx) {\n\t\t\t\tif ((typeof el === \"undefined\" ? \"undefined\" : _typeof(el)) !== \"object\" || Array.isArray(el)) {\n\t\t\t\t\tthrow \"Invalid type (\" + (typeof el === \"undefined\" ? \"undefined\" : _typeof(el)) + \") for action at index \" + idx + \" passed to dispatch. \" + \"Expected object.\";\n\t\t\t\t}\n\t\t\t\tif (!el.hasOwnProperty(\"type\")) {\n\t\t\t\t\tthrow \"Action at index \" + idx + \" passed to dispatch was missing required property: \\\"type\\\"\";\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!action.hasOwnProperty(\"type\")) {\n\t\t\tthrow \"Action passed to dispatch was missing required property: \\\"type\\\"\";\n\t\t}\n\t\tif (typeof rerender !== \"boolean\") {\n\t\t\tthrow \"Invalid type (\" + (typeof rerender === \"undefined\" ? \"undefined\" : _typeof(rerender)) + \") for argument \\\"rerender\\\" passed to dispatch. Expected \" + \"boolean.\";\n\t\t}\n\t}\n\tif (callbackOnion === null) {\n\t\tmiddleware.sort(function (a, b) {\n\t\t\treturn a.priority - b.priority;\n\t\t});\n\t\tcallbackOnion = middleware.reduce(function (nextLayer, layer) {\n\t\t\treturn function (currentAction) {\n\t\t\t\treturn layer.func(currentAction, nextLayer);\n\t\t\t};\n\t\t}, coreFunction);\n\t}\n\tif (!Array.isArray(action)) {\n\t\taction = [action];\n\t}\n\taction.forEach(function (el) {\n\t\tstate = callbackOnion(el);\n\t});\n\tif (rerender) {\n\t\tcallbacks.forEach(function (el) {\n\t\t\tif (typeof el === \"function\") {\n\t\t\t\tel(state);\n\t\t\t} else {\n\t\t\t\tel.updater.enqueueForceUpdate(el);\n\t\t\t}\n\t\t});\n\t}\n};\n\nvar register = function register(actions, reducer) {\n\tif (\"development\" !== \"production\") {\n\t\tif (typeof actions !== \"string\" && ((typeof actions === \"undefined\" ? \"undefined\" : _typeof(actions)) !== \"object\" || !Array.isArray(actions))) {\n\t\t\tthrow \"Invalid type (\" + (typeof actions === \"undefined\" ? \"undefined\" : _typeof(actions)) + \") for argument \\\"actions\\\" passed to listen. Expected string.\";\n\t\t}\n\t\tif (typeof reducer !== \"function\") {\n\t\t\tthrow \"Invalid type (\" + (typeof reducer === \"undefined\" ? \"undefined\" : _typeof(reducer)) + \") for argument \\\"reducer\\\" passed to listen. Expected \" + \"function.\";\n\t\t}\n\t}\n\tif (typeof actions === \"string\") {\n\t\tactions = [actions];\n\t}\n\tactions.forEach(function (action) {\n\t\treducers[action] = reducers[action] || [];\n\t\treducers[action].push(reducer);\n\t});\n};\n\n// https://www.reddit.com/r/javascript/comments/538wgm/suggestions_for_optimal_api_for_a_minimalist/\n// /user/Strobljus made a good point that the ability to unbind middleware (or reducers) is effectively putting state\n// into the middleware (and reducer) lists - instead of keeping all state in the store\n/*\nconst unregister = (actions, reducer) => {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tif (typeof actions !== \"string\" && (typeof actions !== \"object\" || !Array.isArray(actions))) {\n\t\t\tthrow \"Invalid type (\" + (typeof actions) + \") for argument \\\"actions\\\" passed to listen. Expected string.\";\n\t\t}\n\t\tif (typeof reducer !== \"function\") {\n\t\t\tthrow \"Invalid type (\" + (typeof reducer) + \") for argument \\\"reducer\\\" passed to listen. Expected \" +\n\t\t\t      \"function.\";\n\t\t}\n\t}\n\tif (typeof actions === \"string\") {\n\t\tactions = [actions];\n\t}\n\tactions.forEach((action) => {\n\t\tconst index = reducers[action].indexOf(reducer);\n\t\tif (index !== -1) {\n\t\t\treducers[action].splice(index, 1);\n\t\t}\n\t});\n};\n*/\n\nvar listen = function listen(callback, reducer) {\n\tif (reducer) {\n\t\t// Old, deprecated interpretation of \"listen\"\n\t\treturn register(callback, reducer);\n\t}\n\t// New, spiffy interpretation of \"listen\"\n\tif (\"development\" !== \"production\") {\n\t\tif ((typeof callback === \"undefined\" ? \"undefined\" : _typeof(callback)) !== \"object\" && typeof callback !== \"function\") {\n\t\t\tthrow \"Invalid type (\" + (typeof callback === \"undefined\" ? \"undefined\" : _typeof(callback)) + \") for argument \\\"callback\\\" passed to listen. Expected \" + \"function (object accepted for now).\";\n\t\t}\n\t\t// Importing React just to test instanceof means adding 14 kB of overhead for something I intend to deprecate\n\t\t/*\n  if (typeof callback === \"object\" && !callback instanceof React.Component) {\n  \tthrow \"Invalid type (object) for argument \\\"callback\\\" passed to listen. If an object is passed, it \" +\n  \t      \"must be an instance of React.Component.\"\n  }\n  */\n\t}\n\tcallbacks.push(callback);\n};\nvar connect = listen;\n\nvar unlisten = function unlisten(callback) {\n\tvar index = callbacks.indexOf(callback);\n\tif (index !== -1) {\n\t\tcallbacks.splice(index, 1);\n\t}\n};\n\nvar use = function use(newMiddleware) {\n\tvar priority = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n\tif (\"development\" !== \"production\") {\n\t\tif (typeof newMiddleware !== \"function\") {\n\t\t\tthrow \"Invalid type (\" + (typeof newMiddleware === \"undefined\" ? \"undefined\" : _typeof(newMiddleware)) + \") for argument \\\"newMiddleware\\\" passed to listen. \" + \"Expected function.\";\n\t\t}\n\t\tif (typeof priority !== \"number\") {\n\t\t\tthrow \"Invalid type (\" + (typeof priority === \"undefined\" ? \"undefined\" : _typeof(priority)) + \") for argument \\\"priority\\\" passed to listen. Expected \" + \"number.\";\n\t\t}\n\t}\n\tmiddleware.unshift({ priority: priority, func: newMiddleware });\n\t// Additional middleware was added. We need to recalulate this guy.\n\tcallbackOnion = null;\n};\nvar apply = use;\n\nvar getState = function getState() {\n\treturn state;\n};\n\n// Switching to CommonJS allowed a bit better name mangling for dat mad compression\nmodule.exports = {\n\tstate: mutableState,\n\tgetState: getState,\n\tdispatch: dispatch,\n\tregister: register,\n\t//unregister,\n\tlisten: listen,\n\tunlisten: unlisten,\n\tuse: use,\n\tconnect: connect, // Deprecated\n\tapply: apply // Deprecated\n};\n\n\n},{}]},{},[1]);\n"],"sourceRoot":"/source/"}