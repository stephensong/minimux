{"version":3,"sources":["index.js"],"names":["newState","state","action","exports","middleware","reduce","nextLayer","layer","dispatch","coreFunction","i","containers","length","updater","enqueueForceUpdate","type","listeners","push","container","callback"],"mappings":"YAiCKA,SAAWC,UAAfC,GADDC,QALWF,MAKXA,MAAAG,WAAAC,OAAA,SAAAC,EAAAC,GAkBE,MAAO,UAAAL,GARF,MAASM,GAAAA,EAATF,KAENG,cAAAP,EAEA,KAAA,GAAAQ,GAAA,EAAAA,EAAAC,WAAAC,OAAAF,IACAC,WAAAD,GAAAG,QAAAC,mBAAAH,WAAAD,IAIE,QAAaR,QAANa,EAAcT,GACrBU,UAFDD,GAAAC,UAAAD,OAGAC,UAAEP,GAJKQ,KAISf,GAGhBS,QAAcE,SAAQC,GACtBH,WAAAM,KAAAC,GAGK,QAAgBH,OAAMI,GAC5BH,WAAUD,QAAQC,kEA5BHf,SAAAA,iBAkBAC,OAAAA,eAKAW,QAAAA,gBAIOE,MAAAA,KAjChB,IAAId,OAAAA,QAAAA,SACPe,aACAL,cACAP,cAEEK,aAAe,SAAAP,GACpB,GAAIF,GAAWC,KACf,IAAIe,UAAUd,EAAOa,MACpB,IAAK,GAAIL,GAAI,EAAGA,EAAIM,UAAUd,EAAOa,MAAMH,OAAQF,IAR9CV,EAAIC,UAAAA,EAAJc,MAAAL,GAAAV,EAAAE,EAGP,OAAIE","file":"index.min.js","sourcesContent":["/*\n * Minimux v1.0.0\n * Author: Steven Barnett (stevendesu) <steven.abarnett@gmail.com>\n * License: MIT +no-false-attribs (https://spdx.org/licenses/MITNFA.html)\n * \n * I made this library because I liked the ideology of Redux, but not the\n * implementation. This is my attempt to rebuild Redux with absolute minimal\n * functionality and to allow for absolute minimal bootstrapping in order to\n * write effective code.\n *\n * TODO (for anyone who wants to contribute):\n *  - There's currently no error handling or exception throwing. Pass an integer\n *    to dispatch() and the whole thing explodes\n *  - Allow multiple actions to be passed at once\n *  - Cache the \"onion\" so I don't have to rebuild it on every dispatch\n * \n * Considerations:\n *  - Two of our functions (connect and apply) are one-liners... why not just\n *    make \"containers\" and \"middleware\" public?\n *  - What should be the return values of each function?\n *  - How do you UNbind middleware or DISconnect containers? Or UNlisten?\n *  - Should it be possible to connect to a subset of the state? If you could\n *    bind reducers to subsets of state then it would be more modular\n *  - Could we add support for CJS, AMD, and UMD? Maybe as a build step?\n *  - \n */\n\nexport var state = {};\nlet listeners = {};\nlet containers = [];\nlet middleware = [];\n\nconst coreFunction = action => {\n\tlet newState = state;\n\tif( listeners[action.type] ) {\n\t\tfor( var i = 0; i < listeners[action.type].length; i++ ) {\n\t\t\tnewState = listeners[action.type][i](newState, action);\n\t\t}\n\t}\n\treturn newState;\n}\n\nexport function dispatch(action) {\n\t// This function isn't ugly on purpose. I just copied the functionality of\n\t// PHP's Onion library (https://github.com/esbenp/onion/) and translated\n\t// to JavaScript, leaving out unnecessary calls like call_user_func_array\n\t//\n\t// I'm open to anyone who can rewrite this to be a little more obvious\n\t// what's going on\n\tstate = middleware.reduce((nextLayer, layer) => {\n\t\treturn action => {\n\t\t\treturn layer(action, nextLayer);\n\t\t};\n\t}, coreFunction)(action);\n\t// State probably changed. Force re-render\n\tfor( var i = 0; i < containers.length; i++ ) {\n\t\tcontainers[i].updater.enqueueForceUpdate(containers[i]);\n\t}\n}\n\nexport function listen(type, callback) {\n\tlisteners[type] = listeners[type] || [];\n\tlisteners[type].push(callback);\n}\n\nexport function connect(container) {\n\tcontainers.push(container);\n}\n\nexport function apply(newMiddleware) {\n\tmiddleware.unshift(newMiddleware);\n}\n"],"sourceRoot":"/source/"}