{"version":3,"sources":["/source/index.js"],"names":["dispatch","action","rerender","arguments","length","undefined","callbackOnion","middleware","sort","a","b","priority","reduce","nextLayer","layer","currentAction","func","coreFunction","Array","isArray","i","exports","state","containers","updater","enqueueForceUpdate","listen","type","callback","listeners","push","connect","container","apply","newMiddleware","unshift"],"mappings":"YA2CO,SAASA,UAASC,GAAyB,GAAjBC,GAAiBC,UAAAC,QAAA,GAAAC,SAAAF,UAAA,IAAAA,UAAA,EAC3B,QAAlBG,gBACHC,WAAWC,KAAK,SAACC,EAAGC,GACnB,MAAOD,GAAEE,SAAWD,EAAEC,WAQvBL,cAAgBC,WAAWK,OAAO,SAACC,EAAWC,GAC7C,MAAO,UAAAC,GACN,MAAOD,GAAME,KAAKD,EAAeF,KAEhCI,eAECC,MAAMC,QAAQlB,KAClBA,GAAUA,GAEX,IAAImB,EACJ,KAAKA,EAAI,EAAGA,EAAInB,EAAOG,OAAQgB,IAC9BC,QAxCSC,MAwCTA,MAAQhB,cAAcL,EAAOmB,GAE9B,IAAIlB,EACH,IAAKkB,EAAI,EAAGA,EAAIG,WAAWnB,OAAQgB,IAClCG,WAAWH,GAAGI,QAAQC,mBAAmBF,WAAWH,IAKhD,QAASM,QAAOC,EAAMC,GAC5BC,UAAUF,GAAQE,UAAUF,OAC5BE,UAAUF,GAAMG,KAAKF,GAGf,QAASG,SAAQC,GACvBT,WAAWO,KAAKE,GAGV,QAASC,OAAMC,GAA6B,GAAdvB,GAAcR,UAAAC,QAAA,GAAAC,SAAAF,UAAA,GAAH,EAAGA,UAAA,EAClDI,YAAW4B,SAAUxB,SAAAA,EAAUK,KAAMkB,IAErC5B,cAAgB,oEA3CDN,SAAAA,iBA+BA0B,OAAAA,eAKAK,QAAAA,gBAIAE,MAAAA,KA1DT,IAAIX,OAAAA,QAAAA,SACPO,aACAN,cACAhB,cAIAD,cAAgB,KAEdW,aAAe,SAAAhB,GACpB,GAAI4B,UAAU5B,EAAO0B,MACpB,IAAK,GAAIP,GAAI,EAAGA,EAAIS,UAAU5B,EAAO0B,MAAMvB,OAAQgB,IAClDC,QAZQC,MAYRA,MAAQO,UAAU5B,EAAO0B,MAAMP,GAAGE,MAAOrB,EAG3C,OAAOqB","file":"index.min.js","sourcesContent":["/*\n * Minimux v1.0.0\n * Author: Steven Barnett (stevendesu) <steven.abarnett@gmail.com>\n * License: MIT +no-false-attribs (https://spdx.org/licenses/MITNFA.html)\n * \n * I made this library because I liked the ideology of Redux, but not the\n * implementation. This is my attempt to rebuild Redux with absolute minimal\n * functionality and to allow for absolute minimal bootstrapping in order to\n * write effective code.\n *\n * TODO (for anyone who wants to contribute):\n *  - There's currently no error handling or exception throwing. Pass an integer\n *    to dispatch() and the whole thing explodes\n * \n * Considerations:\n *  - Two of our functions (connect and apply) are one-liners... why not just\n *    make \"containers\" and \"middleware\" public?\n *  - What should be the return values of each function?\n *  - How do you UNbind middleware or DISconnect containers? Or UNlisten?\n *  - Should it be possible to connect to a subset of the state? If you could\n *    bind reducers to subsets of state then it would be more modular\n *  - Could we add support for CJS, AMD, and UMD? Maybe as a build step?\n *  - \n */\n\nexport var state = {};\nlet listeners = {};\nlet containers = [];\nlet middleware = [];\n\n// The \"onion\" describes the layers of middleware that we must parse through\n// in order to execute our action.\nvar callbackOnion = null;\n\nconst coreFunction = action => {\n\tif( listeners[action.type] ) {\n\t\tfor( var i = 0; i < listeners[action.type].length; i++ ) {\n\t\t\tstate = listeners[action.type][i](state, action);\n\t\t}\n\t}\n\treturn state;\n}\n\nexport function dispatch(action, rerender = true) {\n\tif( callbackOnion === null ) {\n\t\tmiddleware.sort((a, b) => {\n\t\t\treturn a.priority - b.priority;\n\t\t});\n\t\t// This function isn't ugly on purpose. I just copied the functionality of\n\t\t// PHP's Onion library (https://github.com/esbenp/onion/) and translated\n\t\t// to JavaScript, leaving out unnecessary calls like call_user_func_array\n\t\t//\n\t\t// I'm open to anyone who can rewrite this to be a little more obvious\n\t\t// what's going on\n\t\tcallbackOnion = middleware.reduce((nextLayer, layer) => {\n\t\t\treturn currentAction => {\n\t\t\t\treturn layer.func(currentAction, nextLayer);\n\t\t\t};\n\t\t}, coreFunction)\n\t}\n\tif( !Array.isArray(action) ) {\n\t\taction = [action];\n\t}\n\tvar i;\n\tfor( i = 0; i < action.length; i++ ) {\n\t\tstate = callbackOnion(action[i]);\n\t}\n\tif( rerender ) {\n\t\tfor( i = 0; i < containers.length; i++ ) {\n\t\t\tcontainers[i].updater.enqueueForceUpdate(containers[i]);\n\t\t}\n\t}\n}\n\nexport function listen(type, callback) {\n\tlisteners[type] = listeners[type] || [];\n\tlisteners[type].push(callback);\n}\n\nexport function connect(container) {\n\tcontainers.push(container);\n}\n\nexport function apply(newMiddleware, priority = 0) {\n\tmiddleware.unshift({ priority, func: newMiddleware });\n\t// Additional middleware was added. We need to recalulate this guy.\n\tcallbackOnion = null;\n}\n"],"sourceRoot":"/source/"}